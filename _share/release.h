/******************************************************************************************
* Data Structures in C++ -- 释放成员对象所占的空间的release函数
* 丁酉鸡年二月 2017/3/18 9:31
* @author 西唐王, xtwyzh@gmail.com, xtwroot.com
* xtwroot Copyright (c) 2017. All rights reserved.
******************************************************************************************/

#pragma once

#include <typeinfo.h>

/******************************************************************************************
 * 列表、向量等结构内的节点中，可以存放基本类型或构造类型
 * 按照本书约定，出于效率的考虑，对于后一情况通常只保存对象的指针
 * 因此，在主体结构析构之前，需要首先释放这些成员对象所占的空间
 * 此处，借助C++中偏特化技术区分上述两种情况，并做对应处理
 ******************************************************************************************/

template <typename T> struct Cleaner
{
	static void clean(T x)	//相当递归基
	{
#ifdef _DEBUG
		static int n = 0;
		if (7 > strlen(typeid(T).name()))	//复杂类型一概忽略，只输出基本类型
		{
			printf("\t<%s>[%d]", typeid(T).name(), ++n);
			print(x);
			printf("purged\n");
		}
#endif
	}
};

template <typename T> struct Cleaner<T*>
{
	static void clean(T* x)
	{
		if (x) { delete x; }	//如果其中包含指针，递归释放
#ifdef _DEBUG
		static int n = 0;
		printf("\t <%p>[%d] released\n", typeid(T*).name(), ++n);
#endif
	}
};

template <typename T> void release(T x) { Cleaner<T>::clean(x); }